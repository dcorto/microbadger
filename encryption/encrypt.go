package encryption

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"encoding/base64"
	"errors"
	"io"
	"os"

	"github.com/op/go-logging"

	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/aws/session"
	"github.com/aws/aws-sdk-go/service/kms"

	"github.com/microscaling/microbadger/utils"
)

var (
	log = logging.MustGetLogger("mmenc")
)

const kmsKeySpec = "AES_256"

type Service interface {
	Encrypt(input string) (encKey string, encVal string, err error)
	Decrypt(encKey string, encVal string) (result string, err error)
}

// EncryptionService for encrypting data using KMS.
type EncryptionService struct {
	svc     *kms.KMS
	keyName string
}

// NewService opens a new session with KMS.
func NewService() EncryptionService {
	r := aws.String(utils.GetEnvOrDefault("AWS_REGION", "us-east-1"))
	s := session.New(&aws.Config{Region: r})

	k := os.Getenv("KMS_ENCRYPTION_KEY_NAME")

	return EncryptionService{
		svc:     kms.New(s),
		keyName: k,
	}
}

// Encrypt a string using AES 256 bit encryption. The encryption key is
// generated by KMS and an encrypted copy is returned which must also be stored.
// The encrypted value starts with a random IV that is needed to decrypt.
func (e EncryptionService) Encrypt(input string) (encKey string, encVal string, err error) {
	log.Debug("Encrypting string")

	if e.keyName == "" {
		return "", "", errors.New("Missing encryption key name")
	}

	plaintext := []byte(input)

	plaintextKey, encryptedKey, err := e.generateKey()
	if err != nil {
		log.Errorf("Error generating encryption key - %v", err)
		return "", "", err
	}

	c, err := aes.NewCipher(plaintextKey)
	if err != nil {
		log.Errorf("Error creating encryption cipher  - %v", err)
		return "", "", err
	}

	// Clear key as soon as its no longer needed
	plaintextKey = nil

	// Generate a random IV
	ciphertext := make([]byte, aes.BlockSize+len(plaintext))
	iv := ciphertext[:aes.BlockSize]
	if _, err := io.ReadFull(rand.Reader, iv); err != nil {
		return "", "", err
	}

	stream := cipher.NewCFBEncrypter(c, iv)
	stream.XORKeyStream(ciphertext[aes.BlockSize:], plaintext)

	// Encode as base64 for storing in the database
	encKey = base64.StdEncoding.EncodeToString(encryptedKey)
	encVal = base64.StdEncoding.EncodeToString(ciphertext)

	return encKey, encVal, err
}

// Decrypt a string using AES 256 bit encryption. The encrypted key is first
// decrypted by KMS. The encrypted value starts with a random IV that was
// generated when it was encrypted.
func (e EncryptionService) Decrypt(encKey string, encVal string) (res string, err error) {
	log.Debug("Decrypting string")

	if e.keyName == "" {
		return "", errors.New("Missing encryption key name")
	}

	encryptedKey, err := base64.StdEncoding.DecodeString(encKey)
	if err != nil {
		log.Errorf("Error decoding encrypted key - %v", err)
		return "", err
	}

	plaintextKey, err := e.decryptKey(encryptedKey)
	if err != nil {
		log.Errorf("Error decrypting key using KMS API - %v", err)
		return "", err
	}

	c, err := aes.NewCipher(plaintextKey)
	if err != nil {
		log.Errorf("Error creating decryption cipher - %v", err)
		return "", err
	}

	// Clear key as soon as its no longer needed
	plaintextKey = nil

	encryptedVal, err := base64.StdEncoding.DecodeString(encVal)
	if err != nil {
		log.Errorf("Error decoding encrypted value - %v", err)
		return "", err
	}

	if len(encVal) < aes.BlockSize {
		return "", errors.New("Error cipher text is smaller than block size")
	}

	// Separate the IV and the encrypted value
	iv := encryptedVal[:aes.BlockSize]
	ciphertext := encryptedVal[aes.BlockSize:]

	stream := cipher.NewCFBDecrypter(c, iv)
	stream.XORKeyStream(ciphertext, ciphertext)

	return string(ciphertext), err
}

// Generate an encryption key using the KMS API. The master key is managed by AWS.
func (e EncryptionService) generateKey() (plaintextKey []byte, encKey []byte, err error) {
	params := &kms.GenerateDataKeyInput{
		KeyId:   aws.String(e.keyName),
		KeySpec: aws.String(kmsKeySpec),
	}

	output, err := e.svc.GenerateDataKey(params)
	if err != nil {
		log.Errorf("Error generating data key using KMS API - %v", err)
		return nil, nil, err
	}

	return output.Plaintext, output.CiphertextBlob, err
}

// Decrypt an encryption key using the KMS API.
func (e EncryptionService) decryptKey(encryptedKey []byte) ([]byte, error) {
	params := &kms.DecryptInput{
		CiphertextBlob: encryptedKey,
	}

	output, err := e.svc.Decrypt(params)
	if err != nil {
		log.Errorf("Error decrypting data key using KMS API - %v", err)
		return nil, err
	}

	return output.Plaintext, err
}
